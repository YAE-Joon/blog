***
## 1. Logical vs physical Address
- ![메모리 관리-20250117212057824.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212057824.webp)
- 디스크에서 실행파일이 프로세스로 메모리에 올라가기 전에, 가상 메모리(가상의 주소) 공간을 거쳐서 메모리에 올라가게 된다. 실행파일 마다의 메모리 주소가 있을 텐데, 실제 메모리에는 운영체제가 있고, 다른 프로세스들이 존재하기 때문이다.
- Logical address(virtual address) 
	- 프로세스마다 독립적으로 가지는 주소 공간
	- 각 프로세스마다 0번지부터 시작
	- CPU가 보는 주소는 logical address임
- Physical address
	- 메모리에 실제 올라가는 위치
- 프로그래머는 주소를 생각할 때, 숫자로된 주소가 아니라, 함수이름이나 타입 등, Symbolic Address를 사용한다.
***
## 2. Address Binding

- Symbolic address -->컴파일을 하게되면 Logical address로 변환된다. 이를 시작하게되면 Logical address가 Physical address로 변환이 되어야 한다. 이 과정이 Address Binding이라고 하고, 여러가지가 있다.
- ![메모리 관리-20250117212109446.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212109446.webp)
- Compile time binding 
	- 물리적 메모리 주소가 컴파일시 알려진다.(논리적인 주소 = 물리적인 주소)
	- 시작 위치 변경시 재 컴파일
	- 컴파일러는 절대 코드(absolute code)생성
	- 현재의 멀티태스킹 환경에서는 비효율적
- Load time binding
	- 논리적인 주소가 물리적 메모리주소로 바뀌는 시점을 실행시점에 바뀌게 된다.
	- 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능
	- 
- Run time binding
	- 프로그램이 실행되는 도중에 물리적 메모리 주소가 변할 수 있다. 시작 이 후에도 프로세스의 메모리 상 위치를 옮길 수 있다.
	- CPU가 주소를 참조할 때마다 binding을 점검(address mapping table) : 주소가 물리적인 주소 어디인지를 확인
		- CPU는 하드웨어, 물리적인 주소를 바라볼 것 같지만, CPU는 logical address를 본다. 코드 안에는 논리적인 주소를  바라보고 있다. 만약 이를 바꾸기위해서는 컴파일을 다시해야한다. 즉, 기계어 안에 있는 논리적인 주소를 볼 수 밖에 없다.
		- CPU는 그 때 그 때 주소변환을 해야한다.
	- 하드웨어적인 지원이 필요 (매번 주소변환을 해야하기 때문에)
- MMU(Memory-Management Unit)
	- logical address를 physical address로 변환
	- relocation register : 메모리의 시작 위치 - 여기에 physical memory 시작지점이므로, 논리적 ->물리적 주소 변환
	- limit register : 논리적 주소의 범위(실제 물리적 주소를 넘어가게 되면, 악의적인 메모리 접근방식이기 때문에, trap을 발생시킨다. CPU 제어권이 넘어감)![메모리 관리-20250117212119323.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212119323.webp)
- 용어 정리
	- Dynamic Loading : 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것
		- 프로그램코드는 모든 경우에 다 사용되지 않는다. 보통 예외사항들을 처리하는 코드들이 많음.메모리가 낭비가 되는 것이다. 이런 것을 방지할 수 있다.
		- memory utilization 의 향상 
		- 가끔씩 사용되는 많은 양의 코드의 경우 유용
		- 운영체제의 특별한 지원없이 프로그램 자체에서 구현 가능
		- Loading : 메모리로 올리는 것
	- Overlays
		- 메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림
		- 프로세스의 크기가 메모리보다 클 때 유용
		- 운영체제의 지원없이 사용자에 의해 구현
		- 작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현
	- Swapping
		- 프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것(swap area, 디스크)
		- backing store : 보통 디스크로 쫓아내며, 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간을 의미한다.
		- Swap in/ Swap out 
			- 일반적으로 중기 스케줄러(swapper) 에 의해 swap out 시킬 프로세스 선정 - 중기 스케줄러는 메모리가 부족할시 priority가 낮은 프로세스를 swapped out 시킨다. -> 프로세스는 suspened 상태가 됨
			- Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야 함.
			- Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음
			- swap out이 된 뒤에 다시 swap in을 했을 때, load time binding의 경우 동일한 메모리 주소에 binding해야 한다. 매우 비효율적. 보통 Swapping을 위해서는 Run time binding을 해야한다.
			- swap time 은 대부분 transfer time (swap 되는 양에 비례하는 시간)이다.
		- 보통 이 경우는 통째로 메모리에서 프로세스가 쫓겨나는 경우 이다. 부분적으로  프로세스를 페이징하는 기법도 있음.
	- Dynamic Linking(shared library)
		- Linking을 실행 시간(execution time)까지 미루는 기법
			- 프로그램을 만들 때, 라이브러리가 프로그램의 실행 파일 코드에 포함된다.
			- 내가 만든 코드와 라이브러리가 link가 되어서 실행 파일이 만들어진다.
			- 이 둘을 연결하는 것을 Linking이고, 라이브러리가 프로그램의 실행 파일 코드안에 포함이 되어진다. 이것을 static linking이라고 한다.
		- linking되어서 실행되는 것이 아니라 라이브러리가 실행시(호출될 시에) 연결 된다.
		- 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠
		- 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어온다.
		- 운영체제의 도움이 필요하다.
		- 장점 : 공유의 개념이기 때문에, 확장성이 높다
***
## 3. Allocation of Physical Memory

- 메모리는 일반적으로 . 두영역으로 나뉘어 사용
	- OS 상주 영역
		- interrupt vector와 함께 낮은 주소 영역 사용
	- 사용자 프로세스 영역
		- 높은 주소 영역 사용
- 사용자 프로세스 영역의 할당 방법

- #### Contiguous allocation(연속 할당) :
		- 프로그램이 쪼개지지 않고 통째로 올라가는 방식. 주소변환이 비교적 간단하다.(register 2개만 이용- limit register, relocation register)
		- 고정 분할 방식 (Fixed partition)
			- 물리적인 메모리를 몇 개의 partition으로 미리 나누어 놓는다.각각의 partition에는 프로그램이 하나씩 들어갈 수 있는 상황
			- 내부조각(분할의 크기가 고정되어 있어 남는 공간이 생김)이 있어 비효율적이다.
			- 외부조각(분할의 크기가 너무 작아 활용이 되지 않음)이 있어 비효율적이다.
		- 가변분할(Variable partition)
			- 운영체제 영역, 메모리 영역은 나누어 놓지 않는다.
			- 실행 이후 프로그램이 종료가 되면, 그 위치에 다른 프로그램이 올라갈 수 있지만, 연속할당을 하고 있어, 프로그램이 크다면, 넣을 수 없다. 외부조각이 생기게 된다.
			- 내부조각은 생기지 않는다.
		- 2가지 방식 모두 현대에서는 사용되지 않는다.
		- Hole
			- 가용 메모리 공간.
			- 다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있다.(계속해서 사용을 하게 된다면.)
			- 프로세스가 도착하면 수용가능한 hole을 할당
			- 운영체제는 다음의 정보를 유지
				1. 할당 공간
				2. 가용 공간(hole)
		- Dynamic Storage-Allocation Problem : 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제
			- First-fit : Size 가 n이상 중 가장 최초로 찾아지는 hole에 할당
				- 속도 효율
			- Best-fit : Size 가 n 이상 중, 가장 작은 hole을 찾아서 할당
				- Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야 함
				- 많은 수의 아주 작은 hole들이 생성
					공간효율 
			- Worst-fit : 가장 큰 hole에 할당
		- compaction
			- 사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것
			- 매우 비용이 많이 드는 방법
			- 최소한의 메모리 이동으로 compaction하는 방법 -> 매우 복잡한 문제가 발생
			- 실행 시간에 동적으로 재배치가능한 경우에만 실행 가능함. binding 중에 runtime binding에서만 가능하다. 
	- #### Noncontiguous allocation(불연속 할당)
		- 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음.
		- Paging 
			- Process 의 virtual memory를 동일한 사이즈의 page 단위로 나눔
			- Virtual memory의 내용이 page 단위로 noncontiguous하게 저장
			- 일부는 backing storage(swap area,보조 기억장치)에, 일부는 physical memory에 저장
			- Basic Method
				- physical memory를 동일한 크기의 frame으로 나눈다.
				- logical memory도 동일 크기의 page로 나눈다.
				- 모든 가용 frame들을 관리
				- page table을 사용하여 logical address -> physical address로 변환
				- 외부 조각은 발생하지 않음.(External fragmentation)
				- 내부 조각은 발생할 수 있음.(Internal fragmentation) -> 같은 크기로 자르다보면, 마지막 부분은 자투리 공간이 남을 수 있다.
			- 예시![메모리 관리-20250117212127955.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212127955.webp)
			- table 자료구조를 통해 주소변환이 이루어진다. 1번 page 가 4번 frame에 올라가 있기 때문에 저런식으로 변환을 해준다.
			- page가 올라가지 않는 경우도 있다.
			- 보통 주소는 32bit 이다. 32bit 면 주소의 수는 2^32, 4gb 의 주소를 가질 수 있다. 그런데 여기에 4kb로 나누게 되면, 100만개가 넘는 page가 나오게 되고, 각각의 page table entry가 필요하므로, 같은 수의 page table entry가 만들어지게 된다.
			- 같은 kb내에서 얼만큼 떨어져있는지로 구분하므로, 4kb로 나누어진 page frame에서 그 위치만큼의 offset 정보가 필요하다.
			- Page table 은 main memory에 상주
			- 기존 register 2개는 -> Page-table base register(PTBR), Page-table length register(PTLR) 로 쓰인다.
			- 모든 메모리 접근 연산에는 2번의 memory access 필요 -> page table에 접근 + data/instruction 접근 
			-  속도 향상을 위해 associative register 혹은 translation look-aside buffer(TLB)라 불리는 고속의 lookup hardware cache 사용 (주소변환을 전담하는 빠른 캐시를 두었음)
			- 캐시메모리는 메인메모리와 레지스터 사이에 존재. 완충 역할을 한다. TLB도 일종의 캐시메모리이다. 캐시메모리는 2가지가 있음. 데이터와 주소변환. 그중 하나임.
			- ![메모리 관리-20250117213647140.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117213647140.webp)
			- TLB는 일부만 가지고 있기 때문에, index를 가지고 접근할 수 없음. 논리적인 page 번호와, frame number를 함께 가지고 있어야 한다. page table은 이 page 번호는 필요가 없었다. index가 page번호였기 때문
			- 위에서부터 순차적으로 모두 찾는건 overhead가 크기 때문에, 병렬적으로 한번에 찾음. 이는 하드웨어로 만들어주어야하는데 이를 associative register 라고 한다. (parella search가 가능)
	- Two-Level Page Table
		- paging의 좋은 점은 메모리를 효율적으로 사용할 수 있다. 하지만, process마다 table이 존재하고 백만개씩 된다. 4byte 짜리가 백만개이므로, 4mb가 필요하다.현대 컴퓨터는 이 page table에 의해 큰 공간낭비가 일어난다.
		- page table을 2단계로 구성한다.
		- 바깥쪽 page table과 안쪽 page table이 있다. 논리 주소를 주면 , 바깥쪽 page table 통과 -> 안쪽 page table 통과로 두번 page table을 통과하게 된다.![메모리 관리-20250117212132475.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212132475.webp)
		- 주소 변환을 위해 메모리 두번 접근, 실제 데이터 접근을 위한 메모리 접근 한 번으로, 메모리 접근이 한번 늘어나서 시간적으로 굉장히 손해이다. 공간적으로는 이득이다. 왜 이득인가?
			- 프로세스 관점에서 프로세스는 Code, data, stack으로 이루어져 있다. Code 와 data는 실제로 백만개의 data를 가지고 있지 않고, 사용안되는 부분이 있다.이 부분이 낭비가 되는데, 2단계 table을 쓰게 되면, 바깥 쪽 table을 따라가면, null인 부분이 있다. 
			- 안쪽 table 하나의 크기가 4kb이다. entry는 4byte이므로, 갯수는 1k개이다.
		- 주소 변환 되는 과정 : 
			- 3부분으로 나뉜다. p1, p2, d
				- d: page offset, page안에서 얼마나 떨어져 있는가, 12bit가 된다. 한 page는 4kb이고, 4k만큼의 개수가 필요하게 된다. 2^12 이므로, 12bit가 있으면 된다.
				- p1, p2는 index번호인데, 10bit씩이다. 이렇게 page 번호가 나누어진다.
				- p1, p2가 10bit인 이유 : 위에서부터 몇 번째 entry인가? 하나가 4kb이고, entry하나가 4byte이므로, 1k개를 구분해야한다. -> 10bit가 된다. p1은 32 -12-10 이므로 10bit가 된다.
			- Page Table의 시작위치는? -> PTBR 이 가지고 있다. 위에서 p1번째 떨어진 위치를 가면, 2가지 경우의 수가 나온다. 아무것도 가지지 않은 경우 null, 또는 안쪽 table번호
		- page table의 각 eentry 마다 bit를 두게 된다.
			- protection bit : page에 대한 접근 권한 -> 주소변환을 하더라도 자기자신의 주소공간만 볼수 있음. -> 그럼 왜 필요한가? -> 접근 권한이 read/write를 모두 할 수 있는지,read만 할 수 있는지를 권한 확인 (ex. Code page 를 변경하려고 한다면, 문제가 됨.) 
			- Valid-invalid bit : 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함. (실제로 paging을 하고 메모리에 올리지 않는 경우가 있기 때문에 이를 확인)
	- Inverted Page Table Architecture
		- 원래의 page table은 논리주소에서 물리주소를 변환하는 과정이다. page table의 공간낭비가 너무 심하다.이를 막기위한 방법으로, 물리적인 메모리 frame 당, page table entry가 존재한다.(반대로 되어있음) Process에 반대로 접근한다.
		- 좋은 점은, System wide하게 table이 하나만 있으면 된다. 하지만 주소변환 자체에는 도움이 안된다. 물리적인 주소를 주면 논리적인 주소를 얻을 수 있는데, 논리적인 주소를 가지고 물리적인 주소를 얻어야하는 상황이기 때문이다. 
		- 프로세스마다 p번째 페이지가 존재한다. 따라서, 논리적인 페이지 번호 외에 누구의 페이지인가하는 process id 를 가지고 있어야 한다. 또한 모든 table을 검색을 해야 한다는 단점이 있다.
	- Shared page Table
		- 동일한 프로그램이 여러개 열린 경우에는, Code 부분은 동일하다. 이를 메모리에 하나만 올리고, 공유하는 방식(read only로, 읽기만 됨), shared memory와는 다른 개념(read write가 모두 가능)
		- 두번째는 동일한 logical address에 있어야한다.(여러 프로그램에서 각각 컴파일을 해서 만들었다고 해도, 기계어의 위치는 바뀌면 안된다. 즉, logical address 도 같아야 한다.)
	- 주소 변환의 역할은 전적으로 하드웨어의 역할이다. 운영체제가 하는 일은 아님.
		- 예외로 I/O접근은 반드시 O/S를 통해서 한다.
***
## 4. Segmentation 
- 프로그램을 의미 단위인 여러 개의 segment로 구성
	- 예) Code, Stack, Data 등, 의미를 기준으로 잘라서 페이징하는 방식, 균일할 것이라는 보장은 없다.
	- Code 에서 함수단위로 더 쪼갤 수도 있다.
- Segment table이 존재한다. Paging Table과 비슷하나 차이점도 있다.
	- `<segment-number, offset>`으로 logical address 가 구성된다.![메모리 관리-20250117212138511.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212138511.webp)
	- segment 시작위치를 물리 주소에서 받아오고, 몇번째인지 offset정보를 받아온다.
	- paging에서는 필요없었지만, segment길이 정보가 필요하고 , 이를 table에 저장한다.
	- segment 길이보다 큰 offset이면 잘못된 접근이기 때문에 trap을 발동시킨다.
	- register 2개는 paging 과 비슷하다. 
		- Segment-table base register(STBR) : 물리적 메모리에서 segment table의 위치
			- segment가 시작되는 base는 byte 주소여야 한다. 같은 용량을 가지지 않기 때문.
		- Segment-table length register(STLR) : 프로그램이 사용하는 Segment의 수
	- segment는 크기가 제각각이기 때문에, 결국 이전의 외부조각의 문제가 발생한다. 결국 같은 문제
		- first fit/ best fit
		- external fragmentation 발생
	- 장점 : 의미단위로 해야하는 일들에서는 이 segmentation 기법이 유리하다.(protection, Sharing 등) 읽기권한 등
	- 현실적인 문제 : segment table은 entry가 얼마 되지 않는다. 현실적으로 공간낭비는 paging이 훨씬 심하다.
***
## 5. Paged Segmentation 
- segment 가 paging을 하게 된다. 
- segment-table entry 가 segment의 base address를 가지고 있는 것이 아니라, segment를 구성하는 page table 의 base address를 가지고 있다.![메모리 관리-20250117212145674.webp](images%2F%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC-20250117212145674.webp)
-  즉, segment table과 segment마다 page table을 존재한다.