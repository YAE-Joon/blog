  ***
## 1. 프로그램의 실행 (메모리 load)
- 프로그램을 실행하면 메모리에 올라가서 프로세스가 된다.
- 메모리에는 기본적으로 Kernel이 운영체제로 있다.
- virtual memory : 프로그램이 실행되면, 그 프로그램만의 가상의 메모리 주소공간이 존재한다. 각각의 프로세스는 3가지 구성요소로 되어있다.
	- code : 실행파일에 있는 code가 올라오는 부분. 실제 CPU에서 실행할 기계어들이 위치하는 부분
	- data : 데이터가 보관되는 부분. 배열, 변수 잡아서 쓰는 경우 메모리데이터인데, 이것들이 여기에 보관된다. 하지만 함수 안에 있는 지역변수 같은 것들은 stack에 보관된다. 여기에는 전역변수 같은 것들이 보관된다.
	- stack : 모든 프로그램들이 함수구조로 되어있음. 함수를 호출할 경우 돌아와야하는데, 이를 저장하는 곳.
	- 커널도 하나의 프로그램이기 떄문에 이렇게 3가지로 구성되어있다.
		- 운영체제의 코드 : 시스템콜, 인터럽트 처리 코드, 자원관리를 위한 코드, 편리한 서비스 제공을 위한 코드
		- 운영체제의 데이터에는 모든 하드웨어를 관리하기위한 자료구조, 모든 프로세스를 관리하기위한 자료구조를 가지고 있다.(PCB)
		- 운영체제 커널의 stack은 각 프로세스마다 별도로 존재하게 된다.
- 당장 필요한 부분은 메모리에 올라가고, 그 외는 Swap area로 가게 된다.
	
-  함수
	- 사용자 정의 함수
		- 자신의 프로그램에서 정의한 함수
	- 라이브러리 함수
		- 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
		- 자신의 프로그램의 실행 파일에 포함되어 있다.
	- 커널 함수
		- 운영체제 프로그램의 함수
		- 커널 함수의 호출 = 시스템 콜
- 프로그램 실행 순서 
	- ![프로세스 관리-20250117212222192.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212222192.webp)
***
## 2. 프로세스의 개념
- 실행중인 프로그램을 프로세스라고 한다.
- 프로세스의 context : 프로세스의 상태를 말함. 함수를 읽어가면서 현재 어떤 상태인지, CPU 사용량은 얼마인지, 메모리를 얼마나 가지고 있는가, 등 을 말함.
- context
	- CPU 수행 상태를 나타내는 하드웨어 context : program counter(다음에 실행될 메모리공간), 각종 register( 레지스터에 값을 어떤것을 넣고 있는가,)
	- 프로세스 주소 공간 : code, data, stack
	![프로세스 관리-20250117212228286.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212228286.webp)
	- 프로세스 관련 커널 자료구조 : 
		- PCB(Process Control Block) : 각각의 프로세스를 운영체제가 가지고 있으면서 관리하는 자료구조. CPU를 얼마나 쓰는지, 메모리를 얼마나 쓰는지 등을 관리
		- Kernel stack
***
## 3. 프로세스의 상태
- 프로세스는 상태(state)가 변경되며 수행된다.
- Running : CPU는 하나이기 때문에, CPU에서 기계어를 수행하는 프로세스는 하나이다. CPU를 잡고 instruction을 수행중인 상태
- Ready : CPU를 기다리는 상태(메모리 등, 다른 조건을 모두 만족)
- Blocked(wait, sleep) : CPU를 주어도 당장 instruction을 수행할 수 없는 상태. Process 자신이 요청한 event(ex. I/ O를 대기하는 상태)가 즉시 만족되지 않아 이를 기다리는 상태
- New: 프로세스가 생성중인 상태
- Terminated: 수행(execution)이 끝난 상태
 - 프로세스 상태의 흐름![프로세스 관리-20250117212238425.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212238425.webp)
 ***
## 4. Process Control Block(PCB)
- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 여러 구성요소를 가진다.
	1. OS가 관리상 사용하는 정보
		- Process state, Process ID, scheduling information, priority
	2. CPU 수행 관련 하드웨어 값
		- Program counter, registers
	3. 메모리 관련
		- Code, data, stack의 위치 정보 (CPU를 얻거나 뺏길때, 다음 context를 수행해야하기 때문에, 이런 것들을 저장을 해야한다.)
	4. 파일 관련
		- Open file descriptors
	![프로세스 관리-20250117212245085.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212245085.webp)
- Context Switch : CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
	- CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
	- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴 ![프로세스 관리-20250117212250451.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212250451.webp)
	- 예외 사항) User mode(process A) -> interrupt나 system call에 의해 kernel mode로 이동 후 다시 User mode(process A) 경우는 context switch라고 하지 않는다. 다른 process로 이동하는 경우를 말한다
	- 예외 사항의 경우에는 CPU 수행 정보등 context의 일부를 PCB에 save해야 하지만, 문맥교환을 하는 경우에는 그 부담이 훨씬 크다. 그 이유는 cache memory flush 가 일어나기 때문
***
## 5. 프로세스 스케쥴링을 위한 큐
- Job queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device queue : I/O device의 처리를 기다리는 프로세스의 집합
***
##  6. 스케쥴러(Scheduler)
- Long-term scheduler (job scheduler)
	- 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정 
		- new 상태에서 -> ready로 갈 때, admitted 해주는 역할
		- ready 로 간다는 것은 메모리에 올라간다는 뜻이다. 메모리는 한정된 자원으로서, 너무 많은 프로그램이 올라가면 성능이 떨어진다.
		- 최근 컴퓨터 시스템은 이런 시스템이 없다. 곧바로 ready상태로 들어감
	- 프로세스 memory(및 각종 자원)을 주는 문제
	- degree of Multiprogramming을 제어
		- 메모리에 여러 프로그램이 올라가는 것을 Multiprogramming이라고 한다. 이를 조절한다.
	- time sharing system 에는 보통 장기 스케쥴러가 없음 (무조건 ready)
		- 메모리관리는 어떻게 하는가? -> 중기 스케쥴러가 대신 한다.
- Short-term scheduler(CPU scheduler)
	- 어떤 프로세스를 다음번에 running시킬지 결정
	- 프로세스에 CPU를 주는 문제
	- 충분히 빨라야 함
- Medium-Term Scheduler(중기 스케쥴러 or Swapper)
	- 메모리가 너무 부족할 때 특정 프로세스를 통째로 메모리에서 디스크로 쫓아내는 역할
	- 프로세스에게서 memory를 뺏는 문제
	- degree of Multiprogramming을 제어
- Suspended(stopped)
	- 중기 스케쥴러에 의해 프로세스가 메모리에서 쫓겨난 상태가 새로 생기게 되었다.
	- 외부적인 이유로 프로세스의 수행이 정지된 상태
	- 프로세스는 통째로 디스크에 swap out 된다.
	- 예 ) 사용자가 프로그램을 일시 정지시킨 경우(break key)
		- 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)
	- Suspended vs Blocked (외부에서 resume해주어야 Active, vs 자신이 요청한 event가 만족되면 ready)
	- 새로운 상태도![프로세스 관리-20250117212255519.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212255519.webp)
	- Suspended는 inactive로 정지된 상태이지만. 이 프로세스가 I/O 작업을 하던 상태에서 Suspened인 상태가 되었다면, 이 I/O작업이 끝났다면, Suspended Ready로 돌아올 수 있다.
	- 이 상태에서는 Running 모드에서도 2가지로 나누어 놓았다. User mode 와 monitor mode
		- User mode : 프로세스가 자기 code를 수행할 경우
		- monitor mode : System call에 의해 커널의 코드를 수행할 때는 운영체제가 CPU를 빼앗았다기 보다는 process가 커널에 코드를 수행해달라고 함수를 호출하였기 때문에 process 는 모두 running상태라고 본다.(interrupt인 경우도 마찬가지)
***
## 7. Thread
- process는 메모리 주소공간이 하나씩 만들어지고, PCB가 각각 만들어 질 것이다.
	- 효율적인 방법을 고안(ex. 웹브라우저를 여러개를 띄우더라도, 그 code는 같을 것이기 때문에, 여러 copy가 memory에 올라가게 된다. context안에서는 다른 위치일 것이다.(data나 stack, register는 다를 것이다.) 이 상황이 매우 비효율적
- Tread : 동일한 프로그램을 여러개 띄우더라도, 메모리 공간은 하나씩만 만들어지고, 대신 여러개 띄워진 것들은 다른 공간을 실행할 수 있다. 현재 CPU가 어느 부분을 수행하는 것인가만 다르다. 이를 Thread라고 한다.![프로세스 관리-20250117212304694.webp](images%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC-20250117212304694.webp)
- Process에서 CPU 수행 부분만 따로 가지고 있고, Code는 하나로 수행을 한다.
- 장점 : process의 Context Switch는 굉장히 큰 작업이다. overhead가 많은 작업. context를 save하고  
***
## 8. Process 관리 
- Process Creation(생성)
	- 부모 프로세스가 자식 프로세스를 생성
		- 직접만들지는 못하고, OS에 요청. System call을 한다. 이 경우는 fork() 시스템 콜이라 한다.
	- 프로세스의 트리(계층 구조)형성
		- 부모 프로세스가 자식프로세스를 생성하므로,
	- 프로세스는 자원을 필요로 함
		- 운영체제로부터 받는다.
		- 부모와 공유한다.(thread와는 다른개념. 부모 자식 프로세스는 별개 프로세스. 보통은 경쟁 관계 일부 공유가능)
	- 자원의 공유
		- 부모와 자식이 모든 자원을 공유하는 모델
		- 일부를 공유하는 모델
		- 전혀 공유하지 않는 모델
	- 수행
		- 부모와 자식은 공존하며 수행되는 모델
		- 자식이 종료될 때까지 부모가 기다리는 모델
	- 주소 공간(Address space)
		- 자식은 부모의 공간을 복사함(binary and OS data)
		- 자식은 그 공간에 새로운 프로그램을 올림
		- 유닉스 예시 ) fork() 시스템 콜이 새로운 프로세스를 생성
			- 부모를 그대로 복사(OS data except PID + binary)
			- 주소 공간 할당
			- fork() 다음ㅇ 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림, 
				- exec()은 완전히 새로운 프로그램을 덮어씌움
- Process Termination
	- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit) ->정상 종료되는 경우
		- 자식이 부모에게 output data를 보냄 (via wait)
		- 프로세스의 각종 자원들이 운영체제에게 반납됨
	- 부모 프로세스가 자식의 수행을 종료시킴(abort) -> 강제 종료
		- 자식이 할당 자원의 한계치를 넘어섬
		- 자식에게 할당된 task가 더 이상 필요하지 않음
		- 부모가 종료(exit)하는 경우
			- 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
			- 단계적인 종료 :맨 밑에서부터 단계적으로 종료됨
***
## 9. fork() ,exec(), wait(), exit() 시스템 콜

- fork() : 이 함수는 새로운 프로세스를 하나 복제를 하고, 그 아래 부분을 계속해서 실행. 복제된 함수는 main함수의 시작부분부터 하는 것이 아니라, 자식 프로세스도 부모의 문맥을 그대로 물려받았기 때문에, 동일한 컨텍스트부터 시작된다. 하지만 , pid 값은 다르기 때문에, 이는 부모 자식 관계를 구분지어줄 수 있다.
- exec() : 하나의 프로세스를 완전히 다른 프로세스로 덮어씌우는 함수이다. fork만으로는 모든 프로세스는 동일하게 진행되어야 한다. 다른 프로세스들을 실행되게 하기위한 함수이다.
- wait() : 부모프로세스가 fork() 로 인해 copy된 자식프로세스가 만들어진다. 이 후 wait() 시스템 콜을 해주게 되면, 커널은 자식프로세스가 끝날 때 까지 부모 프로세스를 blocked(sleep)상태로 두게 된다.  자식 프로세스가 종료되면 다시 CPU를 얻을 수 있게 된다.
- exit() : 프로세스를 종료
	- 자발적 종료 : 마지막 statement 수행 후 exit() 시스템 콜을 통해 프로그램을에 명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어준다.
	- 비자발적 종료 : 부모 프로세스가 자식 프로세스를 강제 종료시킨다.
		- 자식 프로세스가 한계치를 넘어서 자원요청
		- 자식에게 할당된 태스크가 더 이상 필요하지 않음
		- 키보드로 kill, break 등 을 친 경우
		- 부모가 종료하는 경우 : 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨.
***
## 10. 프로세스간 협력
- 독립적 프로세스 : 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.
- 협력 프로세스 : 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수해에 영향을 미칠 수 있다.
- 프로세스 간 협력 메커니즘 (IPC : Interprocess Coummunication)
	- message passing : 커널을 통해 message를 전달 (process P send -> process Q receive)
	- shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음.    