---
title: "객체 지향 프로그래밍"
description: "java 언어에 대한 기본 내용"
tag: ["JAVA","클래스","상속","은닉","SOLID"]
---

***
## 1. 클래스 (Class)

- 객체를 프로그램 상에서 사용하려고 기술해 놓은 설계도.
- 추상화 작업을 통해 추상화된 객체를 추출할 때 특징들을 필드와 메서드로 분류
- 객체 생성을 위해서는 반드시 상응하는 클래스가 필요, 객체 생성은 new 연산자 + 클래스의 생성자를 호출해서 진행한다.
- Java에서의 클래스는 가장 기본적인 코드 작성 단위이며 클래스 내에서 작성해야함.
***
## 2. 메서드 (Method)

 - 함수(function)
	특정 작업을 수행하는 명령(코드)들의 단일 집합.
	변수와 달리 호출(call,실행)이 가능하며, 함수 이름 및 괄호를 사용해서 호출.
	코드의 구조화// 반복되는 코드들을 별도의 함수로 묶어서 작성, 호출코드로 대체하면 전체 코드가 간결해짐.
	반복한다고 해서 꼭 함수로 묶는게 좋은 것이 아님.
	
-  메서드의 정의 
	객체에 귀속된 함수. 객체의 동사적 요소를 코드로 표현할 때 사용. 일반 함수와는 다르게 귀속되어 있는 객체의 명사적 요소에 접근 가능. 
	객체에 붙어있는 함수
	
- 메서드의 특징
	- input : 매개변수, output: 리턴값 
		매개변수는 parameter, 매개변수에 담긴 값은 argument라고 함.
	- static 이 명시되지 않은 메서드는 객체가 new 연산자 및 생성자를 통해 생성되지 않으면 사용할 수 없다.
	- 외부 (다른 메서드 안)에서 메서드를 사용하는 행위를 메서드 호출(method call)이라고 얘기한다. 반대로 메서드 입장에서는 '호출되었다.'라고 표현함.
	- 접근 제한자를 설정하지 않으면 상속의 대상이 됨.
	- final 키워드를 사용할시 오버라이딩을 할 수 없다.
	- main 메서드는 특수 함수, java프로그램을 실행시에 가장 먼저 실행되는 메서드, 공식적인 프로그램의 시작점
	- static 메서드 : 동일 클래스 내에서 static을 제외한 일반 메서드를 호출할 수 없다.
	- 생성자 : new 연산자와 클래스로 객체를 생성할 때 반드시 호출 되는 메서드이다. 객체가 생성될 때 한번만 호출되면 이후에는 다른 메서드에서 호출할 수 없다. 메서드이기 때문에 오버로딩이 가능, 클래스 상속 시 오버라이딩은 불가능, 상위 클래스의 생성자를 호출할 때 super라는 키워드를 사용해서 호출함.
	- 생성자는 예외적으로 다른 생성자를 this()로 호출할 수 있다. this 생성자 본문의 가장 첫 번째 줄에 위치 해야함. 
	생성자간 순환 호출을 하면 안됨. 서로가 서로를 계속 불러서 무한 호출 상태로 빠지기 때문에 .

***
## 3. 객체지향 프로그래밍

- 객체
	우리가 표현할 수 있는 실제 세계의 모든 사물
- 개념적 객체
	명확한 실체가 아니라 사람의 지식에 의한 객체
- 물리적 객체
	실제 존재하는 객체
	객체지향 프로그래밍이란 현실세계에서 객체간 상호작용을 프로그래밍 방법론으로 체계화
- 코드를 데이터와 동작을 캡슐화된 독립적인 모듈단위(객체)로 구성하고, 코드 재사용 및 유연성을 높이며 실제 개체의 모델링을 하는 프로그래밍 패러다임
- 프로그래밍 관점에서의 객체의 두가지 요소
	- 필드
		내부적으로 가지고 있는 데이터
	- 메서드
		행위를 의미
*** 
## 4. 객체지향의 4가지 특징	

#### 4.1 추상화(abstraction)

- 특정 객체를 우리가 구상하는 도메인(세계관) 속에서 일반화(Generalize)하는 과정
- 도메인 속 필요한 객체들의 속성/행위(필드와 메서드)를 남기고 불필요한 속성/행위들은 제외시켜야함(일반화)
- 필요시 속성/행위를 추가가능

#### 4.2 은닉화(encapsulation)

-  객체 내부의 속성들을 외부로부터 숨기는 과정  
- 왜 숨기는가? 원래 의도는 내가 설계한 대로 객체를 사용하길 바라기 때문이다. 객체의 내부 속성들을 모두 접근 가능하게 한다면, 개발자의 의도와 다르게 변경이 될 수 있다. 이를 위해 접근이 가능한 속성들과 접근이 불가능한 속성들로 접근을 제어한다.

#### 4.3 상속(inheritance)

- 클래스 간에 관계가 존재하며 그 관계는 상위 클래스와 하위 클래스로 나뉜다. 상위 클래스를 부모 클래스, 하위 클래스를 자식 클래스라고 말하며, 하위 클래스는 상위클래스의 필드 및 메서드를 동일하게 물려받는 것을 상속이라 한다. 
- 자식 객체를 생성하기 위해서는 부모 객체를 먼저 생성 후 자식객체가 생성된다.
- 은닉화에 의해 접근이 제한된 속성들에 대해서 상속의 개념을 적용하기 위해, 접근 제한을 나누었다.(protected)
#### 4.4 다형성(polymorphism)

- 한 객체가 여러 타입의 객체로 취급될 수있는 능력
- 역할과 구현으로 세상을 구분하여 각각의 역할(인터페이스)만 주어지고, 유연성과 변경이 용이해지도록 다형성을 이용할 수 있다.
	- **역할과 구현의 분리**
		- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해짐
		- 장점
			- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
			- 클라이언트는 구현 대상의 내부 구조를 알지 못해도, 변경해도 영향을 받지 않는다.
			- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
	- 자바 언어의 다형성을 활용
	- 역할 = 인터페이스
	- 구현 = 인터페이스를 구현한 클래스, 구현 객체
	- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기 
	- 클라이언트: 요청, 서버: 응답
	- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.
- 자바 언어의 다형성
	- 오버라이딩을 확인.
	- 오버라이딩 -> 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다
	- 클래스 상속 관계도 다형성, 오버라이딩 적용 가능
- 다형성의 본질
	- 인터페이스를 구현한 객체 인스턴스를 실행 시점에서 유연하게 변경가능
	- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야함
	- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.	

***
## 5.  객체 지향 설계의 5가지 원칙(SOLID)

#### 5.1 SRP : 단일 책임 원칙(single responsibility principle)
-   한 클래스는 하나의 책임만 가져야 한다.

#### 5.2 OCP : 개방-폐쇄 원칙(Open/closed principle)
-  소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.

#### 5.3 LSP : 리스코프 치환 원칙(Liskov substitution principle)
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

#### 5.4 ISP : 인터페이스 분리 원칙(Interface segregation principle)
- 범용적인 인터페이스를 사용하기보다 특정 클라이언트를 위한 인터페이스를 여러 개 생성해야 한다.

#### 5.5 DIP : 의존관계 역전 원칙(Dependency inversion principle)
-  추상화에 의존하고, 구체화에는 의존하지 않는다.