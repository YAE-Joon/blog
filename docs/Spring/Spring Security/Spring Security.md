***
## 1. 인증과 인가
- 인증 : 사용자가 주장하는 신원이 실제인지 확인하는 과정
	- 방식 : 비밀번호(보안위험이 있음), 2단계 인증(추가적인 절차), 생체 인식(개인의 유니크한 정보사용), 토큰 기반(사용자에게 발급 후 인증, 세션관리가 필요없어 편리)
- 인가 : 사용자가 무엇을 할 수 있는지를 결정
	- 방식: RBAC(역할에 따라 사용자에게 권한 부여), ACL 접근 제어 목록(특정 사용자에게 resource접근 부여)
- 보안 개념의 원칙 : 
	- 기밀성 : 권한이 있는 사용자에게만 데이터 접근해야함.
	- 무결성 : 데이터가 보장되어야 함.
	- 가용성 : 필요할 때 데이터와 리소스에 접근할 수 있어야 함.
- 암호화 : 컴퓨터 기반 알고리즘을 사용
- SSL/TLS 보안 프로토콜 : 인터넷을 통한 네트워크통신을 보호
- 접근 제어 메커니즘 : MAC, DAC, 세션 관리 
***
## 2. Spring Security
- JAVA 기반 보안 프로토콜 
- 모듈화 되어 있고 확장성이 있음.
- HTTP 요청 처리시 보안관련 작업 수행 
- 구성요소
	- Authentication Manager : 인증 담당, 유효성 검사
	- SecurityContext / SecurityContext Holder : 사용자 정보 저장, 사용자 인증 정보 접근
	- AccessDecision Manager : 특정 자원에 대한 접근 결정 (사용자의 권한 -요청 을 매치)
	- UserDetails Service : 사용자 정보 로드(데이터베이스, 다른 소스로부터 데이터를 가져올 수 있음)
	- UsernamePasswordAuthenticationFilter /Jwt AuthenticationFilter : 인증 메커니즘 필터
- 인증 메커니즘
	- 사용자 이름+비밀번호 -> Authentication Manger (인증을 통해 검증) -> Authentication(이 객체를 받아서 유효성을 판단 후 반환)
	- OAuth : OAuth관련 필터를 처리
	- JWT : JWT 관련 필터를 처리 , 다양한 인증 옵션 제공
- 보안 필터, 필터 체인
	- 필터는 HTTP 요청과 응답을 가로채고, 보안관련 작업 수행. 인증 메커니즘은 동일
	- HTTP 요청 ->UsernamePassword AuthenticationFilter 
	- ExceptionTranslation Filter 예외처리 관련 필터 
	- FilterSecurity Interceptor : 권한 부여과정 처리
	- 각각 독립적으로 작용
- 역할 기반 접근 제어(RBAC)
	- 다양한 annotation 에 의해 수행
		- `@PreAuthorize("hasRole('Admin')")` : 메소드가 실행되기 전에, 특정 권한을 가진 메서드만 호출 가능
		- `@PostAuthorize("returnObject.owner ==principal.username")` : 메서드가 실행된 후 반환된 결과에 따라 접근을 제어  
		- `@Secured("ROLE_USER")` : 특정 역할을 가진 사용자만 실행할 수 있는 코드
	- URL 기반 접근 제어 : 특정 URL 패턴에 따라 URL 호출을 허용함 ![Spring Security-20250117214949093.webp](images%2FSpring%20Security-20250117214949093.webp)
- 보안 컨텍스트와 인증 객체 : Spring security에서 인증정보를 저장하는 메커니즘 
	- SecurityContextHolder 를 통해 어플리케이션의 어느 곳에서나 접근이 가능
	- 인증 객체는 사용자 식별정보, 등을 포함하고 있다. 이를 생성하고 보안 컨텍스트에 저장
- 사용자 정의 보안 설정
	- SecurityConfig를 통해 사용자가 원하는 상황에 맞춰 보안설정을 할 수 있게 한다.
- 쿠키와 세션의 문제점 
	- 웹사용성을 향상시키지만 보안 취약점이 많이 있음. 
	- 데이터 노출 위험, 세션 탈취 위험
	- 세션 고정, 세션 만료 관리 -> 세션 ID, HTTPS, 데이터 암호화, 재생성이 필요함.
	- XSS 공격, CSRF 공격
	- 보안설정의 부재
	- 실제 사례 : SNS 세션 탈취 , 온라인 뱅킹 CSRF(가짜 pc website를 통해 접근), e커머스 데이터 유출(취약한 보안으로 개인 신상정보 등이 대량 유출)
	- XSS : 공격자가 website에 가짜 script를 삽입, 실행하게 만든다. 
	- CSRF : 사용자가 인증을 받은 상태에서 악의적인 요청을 보내게 만들게 됨. (계좌이체, 비밀번호 변경)
	- 이러한 문제점으로 보안 강화 대체 방안이 나오게 됨
		- 토큰 기반 인증 : JWT 토큰을 발행. 보안성과 확장성이 높음
		- OAuth : 사용자 인증과 권한부여를 위한 개방형 표준. 외부 서비스와의 안전한 인증 및 데이터 접근 가능. SNS 로그인에 사용
		- OpenID Connect 
		- 웹 스토리지 : 쿠키의 대체수단. 서버에 저장되지 않고 클라이언트측에 저장
		- IndexedDB 
***
## 3. 토큰 기반 인증시스템
- 사용자 인증을 위해 중요하게 사용되는 인증 시스템
- 로그인 -> 사용자 검증 -> 고유한 토큰을 생성 후 사용자 전달 -> 이 토큰으로 권한을 유지(일정 시간)
- 대부분 JWT
- 서버는 토큰의 유효성만 검증하면 되기 때문에, 세션상태를 유지할 필요가 없게 된다.
- 장점 
	- 사용자의 세션 정보를 서버가 아닌 클라이언트에서 관리하기 때문에, 서버의 부담을 줄이고 공격범위를 축소시킬 수 있어 보안성 강화
	- 상태를 유지하지 않으므로 시스템의 확장성과 유연성 증가
	- 접근 제어 및 권한 부여 : 세밀한 접근 제한이 가능함
	- 단일 로그인 구현 용이 : 다양한 어플리케이션과 서비스간 인증정보를 효과적으로 공유할 수 있음. 사용자는 한번의 로그인으로 유지할 수 있는 편리함
- 토큰과 세션의 비교 : 
	- 토큰 : 서버로 토큰을 받고 이후 인증을 통해 서버로 접근. 토큰 관리와 보안이 중요해진다. 토큰의 유출로인한 보안위험이 중요
	- 세션 : 서버의세션에 인증정보를 저장하고, 클라이언트는 세션ID를 통해 인증을 수행, 서버의 직접 관리, 보안이 강화. 확장성이 적어짐.
	- 상태 비교 ![Spring Security-20250117214957247.webp](images%2FSpring%20Security-20250117214957247.webp)
- 토큰의 보안 고려사항
	- 토큰의 안전한 생성
	- 토큰의 전송 보안 : 토큰을 안전하게 전송해야함
	- 토큰의 저장방법 : 쿠키 등, 저장할 때 적절할 보안을 통해 안전하게 저장해야함.
	- 토큰의 유효기간 관리 : 기간을 적절히 조절해야함
	- 접근 제어와 권한 관리 
	- 토큰 갱신 및 폐기
- 토큰인증의 실제 적용 : 토큰 발급 및 관리 (JWT) -> 클라이언트 측 토큰 저장 (로컬 스토리지 등에 저장)-> 토큰을 사용한 요청 인증 (Http header에 포함하여 인증 수행)->토큰 갱신 및 만료 관리 
